#!/usr/bin/env python3
"""
Backend API Tools - Herramientas Simples para CrewAI
ENFOQUE H√çBRIDO INTELIGENTE: Estas herramientas NO contienen l√≥gica compleja.
Solo hacen llamadas HTTP al backend que contiene toda la l√≥gica de negocio.

Cada herramienta es s√∫per simple: recibe par√°metros, llama al backend, devuelve respuesta.
"""

import os
import httpx
import logging
from typing import Dict, Any, Optional
from crewai.tools import BaseTool
from pydantic import BaseModel, Field

# Configuraci√≥n de logging
logger = logging.getLogger(__name__)

# URL del backend (Document Ingestion Service)
BACKEND_URL = os.getenv("DOCUMENT_INGESTION_URL", "https://pipefy-document-ingestion-modular.onrender.com")

class ObtenerDocumentosConContenidoAPITool(BaseTool):
    """
    HERRAMIENTA ULTRA-SIMPLE: Obtiene documentos con contenido parseado autom√°ticamente
    
    BRILLANTE SIMPLIFICACI√ìN: Los documentos YA est√°n parseados cuando se suben.
    Solo necesitamos consultar la tabla documents existente que ya tiene todo.
    
    ¬°No necesitamos endpoints de parseo porque ya est√° integrado en el flujo de subida!
    """
    name: str = "obtener_documentos_con_contenido_api"
    description: str = """
    Obtiene documentos de un caso CON su contenido parseado autom√°ticamente.
    Los documentos se parsean autom√°ticamente al subirlos, as√≠ que aqu√≠ solo consultamos.
    
    Par√°metros:
    - case_id: ID del caso/card cuyos documentos obtener
    - include_content: Si incluir el contenido parseado completo (default: true)
    
    Retorna: Lista de documentos con URLs, metadatos Y contenido parseado listo para an√°lisis.
    """
    
    def _run(self, case_id: str, include_content: bool = True) -> str:
        """
        Consulta la tabla documents que YA TIENE el contenido parseado.
        Ultra-simple: solo una consulta a Supabase.
        """
        try:
            logger.info(f"üìÑ Obteniendo documentos con contenido para case_id: {case_id}")
            
            # Llamada HTTP simple al backend que consulta tabla documents
            with httpx.Client(timeout=30.0) as client:
                params = {"include_content": include_content}
                response = client.get(
                    f"{BACKEND_URL}/api/v1/documentos/{case_id}",
                    params=params
                )
                response.raise_for_status()
                result = response.json()
            
            if result.get("success"):
                documents = result.get("documents", [])
                logger.info(f"‚úÖ Encontrados {len(documents)} documentos con contenido para case_id: {case_id}")
                
                if documents:
                    doc_summaries = []
                    for doc in documents:
                        name = doc.get('name', 'Sin nombre')
                        doc_type = doc.get('document_tag', 'Sin tipo')
                        parsing_status = doc.get('parsing_status', 'unknown')
                        
                        if parsing_status == 'completed':
                            content_length = len(doc.get('parsed_content', ''))
                            confidence = doc.get('confidence_score', 0.0)
                            doc_summaries.append(
                                f"- {name} ({doc_type}): ‚úÖ {content_length} caracteres parseados (Confianza: {confidence:.2f})"
                            )
                            
                            # Si incluir contenido, a√±adirlo para an√°lisis
                            if include_content and doc.get('parsed_content'):
                                doc_summaries.append(f"  CONTENIDO: {doc['parsed_content'][:500]}..." if len(doc['parsed_content']) > 500 else f"  CONTENIDO: {doc['parsed_content']}")
                        else:
                            doc_summaries.append(f"- {name} ({doc_type}): ‚ùå Parseo fall√≥ o pendiente")
                    
                    return f"Documentos con contenido para {case_id}:\n" + "\n".join(doc_summaries)
                else:
                    return f"No se encontraron documentos para el case_id: {case_id}"
            else:
                error_msg = f"Error al obtener documentos: {result.get('message', 'Error desconocido')}"
                logger.error(error_msg)
                return error_msg
                
        except httpx.TimeoutException:
            error_msg = f"Timeout al obtener documentos para {case_id}"
            logger.error(error_msg)
            return error_msg
        except httpx.HTTPStatusError as e:
            error_msg = f"Error HTTP {e.response.status_code} al obtener documentos para {case_id}"
            logger.error(error_msg)
            return error_msg
        except Exception as e:
            error_msg = f"Error inesperado al obtener documentos para {case_id}: {str(e)}"
            logger.error(error_msg)
            return error_msg



class EnriquecerClienteAPITool(BaseTool):
    """
    HERRAMIENTA SIMPLE: Enriquece datos de cliente con CNPJ
    
    El agente solo necesita saber:
    "Para obtener todos los datos de un cliente, uso esta herramienta con el CNPJ"
    
    TODA la l√≥gica compleja (CNPJ√° API, BrasilAPI, fallbacks, etc.) 
    est√° en el backend, no aqu√≠.
    """
    name: str = "enriquecer_cliente_api"
    description: str = """
    Enriquece los datos de un cliente usando su CNPJ.
    Obtiene informaci√≥n completa de la empresa desde m√∫ltiples fuentes.
    
    Par√°metros:
    - cnpj: CNPJ de la empresa (solo n√∫meros)
    - case_id: ID del caso/card para asociar los datos
    
    Retorna: Informaci√≥n completa de la empresa o error si no se encuentra.
    """
    
    def _run(self, cnpj: str, case_id: str) -> str:
        """
        Llama al backend para enriquecer datos de cliente.
        S√∫per simple: solo hace la llamada HTTP.
        """
        try:
            logger.info(f"üîç Llamando al backend para enriquecer CNPJ: {cnpj}")
            
            # Preparar datos para el backend
            payload = {
                "cnpj": cnpj,
                "case_id": case_id
            }
            
            # Llamada HTTP simple al backend
            with httpx.Client(timeout=60.0) as client:
                response = client.post(
                    f"{BACKEND_URL}/api/v1/cliente/enriquecer",
                    json=payload
                )
                response.raise_for_status()
                result = response.json()
            
            if result.get("success"):
                logger.info(f"‚úÖ Cliente enriquecido exitosamente: {cnpj}")
                return f"Cliente enriquecido exitosamente. {result.get('message', '')}"
            else:
                logger.error(f"‚ùå Error al enriquecer cliente: {result.get('message')}")
                return f"Error al enriquecer cliente: {result.get('message', 'Error desconocido')}"
                
        except httpx.TimeoutException:
            error_msg = f"Timeout al enriquecer cliente {cnpj}. El backend tard√≥ m√°s de 60 segundos."
            logger.error(error_msg)
            return error_msg
        except httpx.HTTPStatusError as e:
            error_msg = f"Error HTTP {e.response.status_code} al enriquecer cliente {cnpj}"
            logger.error(error_msg)
            return error_msg
        except Exception as e:
            error_msg = f"Error inesperado al enriquecer cliente {cnpj}: {str(e)}"
            logger.error(error_msg)
            return error_msg



class NotificarWhatsAppAPITool(BaseTool):
    """
    HERRAMIENTA SIMPLE: Env√≠a notificaci√≥n WhatsApp
    
    El agente solo necesita saber:
    "Para enviar una notificaci√≥n WhatsApp, uso esta herramienta"
    
    TODA la l√≥gica de Twilio est√° en el backend.
    """
    name: str = "notificar_whatsapp_api"
    description: str = """
    Env√≠a una notificaci√≥n WhatsApp al responsable de un card.
    
    Par√°metros:
    - card_id: ID del card de Pipefy
    - mensaje: Mensaje a enviar
    
    Retorna: Confirmaci√≥n del env√≠o o error.
    """
    
    def _run(self, card_id: str, mensaje: str) -> str:
        """
        Llama al backend para enviar WhatsApp.
        S√∫per simple: solo hace la llamada HTTP.
        """
        try:
            logger.info(f"üì± Enviando WhatsApp para card_id: {card_id}")
            
            # Preparar datos para el backend
            payload = {
                "card_id": card_id,
                "mensaje": mensaje
            }
            
            # Llamada HTTP simple al backend
            with httpx.Client(timeout=30.0) as client:
                response = client.post(
                    f"{BACKEND_URL}/api/v1/whatsapp/enviar",
                    json=payload
                )
                response.raise_for_status()
                result = response.json()
            
            if result.get("success"):
                logger.info(f"‚úÖ WhatsApp enviado exitosamente para card: {card_id}")
                return f"WhatsApp enviado exitosamente. {result.get('message', '')}"
            else:
                logger.error(f"‚ùå Error al enviar WhatsApp: {result.get('message')}")
                return f"Error al enviar WhatsApp: {result.get('message', 'Error desconocido')}"
                
        except httpx.TimeoutException:
            error_msg = f"Timeout al enviar WhatsApp para card {card_id}"
            logger.error(error_msg)
            return error_msg
        except httpx.HTTPStatusError as e:
            error_msg = f"Error HTTP {e.response.status_code} al enviar WhatsApp para card {card_id}"
            logger.error(error_msg)
            return error_msg
        except Exception as e:
            error_msg = f"Error inesperado al enviar WhatsApp para card {card_id}: {str(e)}"
            logger.error(error_msg)
            return error_msg

class ActualizarPipefyAPITool(BaseTool):
    """
    HERRAMIENTA SIMPLE: Actualiza campos en Pipefy
    
    El agente solo necesita saber:
    "Para actualizar un campo en Pipefy, uso esta herramienta"
    
    TODA la l√≥gica de Pipefy GraphQL est√° en el backend.
    """
    name: str = "actualizar_pipefy_api"
    description: str = """
    Actualiza un campo espec√≠fico en un card de Pipefy.
    
    Par√°metros:
    - card_id: ID del card de Pipefy
    - campo: Nombre del campo a actualizar
    - valor: Nuevo valor para el campo
    
    Retorna: Confirmaci√≥n de la actualizaci√≥n o error.
    """
    
    def _run(self, card_id: str, campo: str, valor: str) -> str:
        """
        Llama al backend para actualizar Pipefy.
        S√∫per simple: solo hace la llamada HTTP.
        """
        try:
            logger.info(f"üìù Actualizando campo '{campo}' en card: {card_id}")
            
            # Preparar datos para el backend
            payload = {
                "card_id": card_id,
                "campo": campo,
                "valor": valor
            }
            
            # Llamada HTTP simple al backend
            with httpx.Client(timeout=30.0) as client:
                response = client.post(
                    f"{BACKEND_URL}/api/v1/pipefy/actualizar",
                    json=payload
                )
                response.raise_for_status()
                result = response.json()
            
            if result.get("success"):
                logger.info(f"‚úÖ Campo actualizado exitosamente en Pipefy: {card_id}")
                return f"Campo '{campo}' actualizado exitosamente en Pipefy. {result.get('message', '')}"
            else:
                logger.error(f"‚ùå Error al actualizar Pipefy: {result.get('message')}")
                return f"Error al actualizar campo en Pipefy: {result.get('message', 'Error desconocido')}"
                
        except httpx.TimeoutException:
            error_msg = f"Timeout al actualizar Pipefy para card {card_id}"
            logger.error(error_msg)
            return error_msg
        except httpx.HTTPStatusError as e:
            error_msg = f"Error HTTP {e.response.status_code} al actualizar Pipefy para card {card_id}"
            logger.error(error_msg)
            return error_msg
        except Exception as e:
            error_msg = f"Error inesperado al actualizar Pipefy para card {card_id}: {str(e)}"
            logger.error(error_msg)
            return error_msg

# Lista de todas las herramientas disponibles para el agente
# VERSI√ìN SIMPLIFICADA: Integraci√≥n elegante con tabla documents existente
BACKEND_API_TOOLS = [
    ObtenerDocumentosConContenidoAPITool(),  # NUEVA: Con contenido parseado integrado
    EnriquecerClienteAPITool(),
    NotificarWhatsAppAPITool(),
    ActualizarPipefyAPITool()
] 